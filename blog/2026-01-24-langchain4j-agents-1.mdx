---
slug: langchain4j-agents-basics
title: LangChain4j 智能体（一）
authors: [susamlu]
tags: [langchain4j, java, llm, agent]
---

基于 AI Services 的基础能力，LangChain4j 进一步构建了 **智能体（Agents）** 框架，原生支持工作流编排、多智能体协作等高级特性。作为该框架的核心单元，智能体是具备自主决策能力、可独立执行特定任务的功能模块，能够通过协同分工、优势互补完成复杂目标。本文将详细介绍 LangChain4j 智能体的基础概念与工作流模式。

<!-- truncate -->

:::info 版本说明
本文基于 **LangChain4j 1.10.0** 版本编写，API 接口与行为特性可能与其他版本存在差异，请以实际使用的版本为准。
:::

:::warning 实验性功能
`langchain4j-agentic` 模块目前处于实验性阶段，在未来的版本中可能会发生变化。
:::

## 智能体系统

目前业界尚未对 AI 智能体形成统一定义，但已涌现出多种新兴架构模式，这些模式展示了如何协调并组合多个 AI 服务，进而构建可完成复杂任务的 AI 应用。此类架构通常被称为“智能体系统”（agentic systems）或“智能体 AI”（agentic AI），其核心是依赖大语言模型（LLMs）实现任务编排、工具管理，并在交互过程中维护上下文信息。

根据 Anthropic 研究人员最近发表的一篇文章，智能体系统架构可划分为两大类：**工作流（workflows）** 和 **纯智能体（pure agents）**。

本教程讨论的 `langchain4j-agentic` 模块提供了完备的抽象层和工具集，帮助开发者构建工作流和纯智能体 AI 应用。该模块支持工作流定义、工具管理，并能在与不同 LLM 交互的过程中维护上下文。

## LangChain4j 中的智能体


LangChain4j 中的智能体基于 LLM 执行一项特定任务或一组关联任务。其定义方式与普通 AI 服务相近，可通过接口实现：只需在接口中声明一个方法，并为该方法添加 `@Agent` 注解即可。

```java title="CreativeWriter.java"
public interface CreativeWriter {

    @UserMessage("""
            你是一位创意作家。
            请围绕给定主题生成一个不超过3句话的故事草稿。
            只返回故事内容，不要返回其他内容。
            主题：{{topic}}
            """)
    @Agent("根据给定主题生成故事草稿")
    String generateStory(@V("topic") String topic);
    
}
```

建议在 `@Agent` 注解中提供智能体用途的简短描述，尤其在纯智能体模式中使用时，其他智能体需通过该描述了解其能力边界，从而合理决策使用场景与调用时机。也可在构建智能体时，通过智能体构建器的 `description` 方法以编程方式配置该描述。

智能体在所属智能体系统中需具备唯一标识名称。该名称可在 `@Agent` 注解中直接指定，也可通过智能体构建器的 `name` 方法以编程方式配置；若未明确指定，名称将默认取自被 `@Agent` 注解的方法名称。

开发者可通过 `AgenticServices.agentBuilder()` 方法指定接口类型与待使用的聊天模型，进而构建智能体实例，具体示例如下：

```java title="AgentBuilderExample.java"
public class AgentBuilderExample {
    
    public static void main(String[] args) {
        ChatModel model = OpenAiChatModel.builder()
                .apiKey(System.getenv("OPENAI_API_KEY"))
                .modelName("gpt-4o-mini")
                .build();
        
        CreativeWriter creativeWriter = AgenticServices
                .agentBuilder(CreativeWriter.class)
                .chatModel(model)
                .outputKey("story")
                .build();
        
        String story = creativeWriter.generateStory("太空探索");
        System.out.println(story);
    }

}
```

本质上，智能体的基础功能与普通 AI 服务一致（均通过 LLM 处理特定任务），但额外具备可组合、可协作的核心特性，能够与其他智能体配合构建更复杂的工作流及智能体系统。

智能体与普通 AI 服务的另一核心区别在于对 `outputKey` 参数的支持，该参数用于指定共享变量名称，智能体调用结果将存储至该变量中，供同一智能体系统内的其他智能体使用。此外，`outputKey` 也可直接在 `@Agent` 注解中声明：

```java
@Agent(outputKey = "story", description = "根据给定主题生成故事草稿")
```

`AgenticServices` 类提供了一组静态工厂方法，用于创建和定义 `langchain4j-agentic` 框架提供的各种智能体。

## AgenticScope 介绍

`langchain4j-agentic` 模块引入了 `AgenticScope` 的概念，其本质是参与智能体系统的各智能体之间共享的数据集合。`AgenticScope` 用于存储共享变量，智能体可向这些变量写入自身产生的执行结果，其他智能体则可读取这些变量，获取任务执行所需的组合信息，从而实现智能体间的高效协作与信息共享。

`AgenticScope` 还会自动注册其他关联信息，例如所有智能体的调用序列及其响应结果。该组件在调用智能体系统的主智能体时自动创建，必要时可通过回调方式以编程形式提供。关于 `AgenticScope` 的具体使用场景，将在后续介绍 `langchain4j-agentic` 实现的智能体模式时，结合实际示例进行详细说明。

## 工作流模式

`langchain4j-agentic` 模块提供了一组抽象能力，支持开发者以编程方式编排多个智能体，构建各类智能体工作流模式。这些模式可灵活组合，进而实现更复杂的工作流逻辑。

### 顺序工作流

顺序工作流是最基础的工作流模式，多个智能体按既定顺序依次调用，前一个智能体的输出将作为后一个智能体的输入。该模式适用于存在明确执行顺序的任务场景。

例如，可通过 `AudienceEditor` 智能体对前文定义的 `CreativeWriter` 智能体进行功能补充，该智能体能够对生成的故事进行编辑，使其更适配特定目标受众。

```java title="AudienceEditor.java"
public interface AudienceEditor {

    @UserMessage("""
            你是一位专业编辑。
            分析并重写以下故事，使其更好地符合目标受众：{{audience}}。
            只返回故事内容，不要返回其他内容。
            故事内容："{{story}}"
            """)
    @Agent("编辑故事以更好地适应给定的目标受众")
    String editStory(@V("story") String story, @V("audience") String audience);

}
```

此外，还可定义功能类似的 `StyleEditor` 智能体，其核心作用是使故事更贴合特定风格要求。

```java title="StyleEditor.java"
public interface StyleEditor {

    @UserMessage("""
            你是一位专业编辑。
            分析并重写以下故事，使其更好地符合并更连贯地体现 {{style}} 风格。
            只返回故事内容，不要返回其他内容。
            故事内容："{{story}}"
            """)
    @Agent("编辑故事以更好地适应给定的风格")
    String editStory(@V("story") String story, @V("style") String style);

}
```

需注意，该智能体的输入参数通过变量名注解指定。实际上，传递给该智能体的参数值并非直接提供，而是从 `AgenticScope` 中名称对应的共享变量中获取，这一机制确保智能体能够访问工作流中前序智能体的输出结果。若智能体类在编译时启用 `-parameters` 选项（确保运行时保留方法参数名称），则可省略 `@V` 注解，变量名将自动从方法参数名中推断出来。

基于上述三个智能体，可构建顺序工作流，使 `CreativeWriter` 的输出作为 `AudienceEditor` 和 `StyleEditor` 的输入，最终输出经过双重编辑的故事内容，具体实现如下：

```java title="SequentialWorkflowExample.java"
import dev.langchain4j.agentic.AgenticServices;
import dev.langchain4j.agentic.Agent;
import dev.langchain4j.agentic.UntypedAgent;
import dev.langchain4j.model.chat.ChatModel;
import dev.langchain4j.model.openai.OpenAiChatModel;
import dev.langchain4j.service.UserMessage;
import dev.langchain4j.service.V;

import java.util.Map;

public class SequentialWorkflowExample {

    public interface CreativeWriter {

        @UserMessage("""
                你是一位创意作家。
                请围绕给定主题生成一个不超过3句话的故事草稿。
                只返回故事内容，不要返回其他内容。
                主题：{{topic}}
                """)
        @Agent("根据给定主题生成故事草稿")
        String generateStory(@V("topic") String topic);

    }

    public interface AudienceEditor {

        @UserMessage("""
                你是一位专业编辑。
                分析并重写以下故事，使其更好地符合目标受众：{{audience}}。
                只返回故事内容，不要返回其他内容。
                故事内容："{{story}}"
                """)
        @Agent("编辑故事以更好地适应给定的目标受众")
        String editStory(@V("story") String story, @V("audience") String audience);

    }

    public interface StyleEditor {

        @UserMessage("""
                你是一位专业编辑。
                分析并重写以下故事，使其更好地符合并更连贯地体现 {{style}} 风格。
                只返回故事内容，不要返回其他内容。
                故事内容："{{story}}"
                """)
        @Agent("编辑故事以更好地适应给定的风格")
        String editStory(@V("story") String story, @V("style") String style);

    }

    public static void main(String[] args) {
        // 创建对话模型
        ChatModel baseModel = OpenAiChatModel.builder()
                .baseUrl("https://api.deepseek.com/v1")
                .apiKey(System.getenv("DEEPSEEK_API_KEY"))
                .modelName("deepseek-chat")
                .logRequests(true)
                .logResponses(true)
                .build();

        // 创建创意作家智能体
        CreativeWriter creativeWriter = AgenticServices
                .agentBuilder(CreativeWriter.class)
                .chatModel(baseModel)
                .outputKey("story")
                .build();

        // 创建受众编辑智能体
        AudienceEditor audienceEditor = AgenticServices
                .agentBuilder(AudienceEditor.class)
                .chatModel(baseModel)
                .outputKey("story")
                .build();

        // 创建风格编辑智能体
        StyleEditor styleEditor = AgenticServices
                .agentBuilder(StyleEditor.class)
                .chatModel(baseModel)
                .outputKey("story")
                .build();

        // 创建顺序工作流：按顺序执行三个智能体
        UntypedAgent novelCreator = AgenticServices
                .sequenceBuilder()
                .subAgents(creativeWriter, audienceEditor, styleEditor)
                .outputKey("story")
                .build();

        // 准备输入参数
        Map<String, Object> input = Map.of(
                "topic", "龙与巫师",
                "audience", "青年",
                "style", "奇幻"
        );

        // 执行工作流
        String story = (String) novelCreator.invoke(input);

        // 输出结果
        System.out.println("=== 最终生成的故事 ===");
        System.out.println(story);
        System.out.println();
        System.out.println("=== 工作流执行完成 ===");
    }

}
```

上述代码中的 `novelCreator` 智能体本质是一个实现顺序工作流的智能体系统，其整合了三个子智能体并按顺序调用。由于该智能体未提供类型化接口定义，序列智能体构建器返回 `UntypedAgent` 实例，这是一种通用智能体，支持通过输入映射进行调用。

```java
public interface UntypedAgent {

    @Agent
    Object invoke(Map<String, Object> input);
    
}
```

输入映射中的值会被复制到 `AgenticScope` 共享变量中，供子智能体访问；`novelCreator` 智能体的输出则取自 `AgenticScope` 中名为 `story` 的共享变量，该变量在工作流执行过程中会被所有子智能体重写更新。

此外，工作流智能体也可提供类型化接口，支持通过强类型输入和输出进行调用。此时，`UntypedAgent` 接口可替换为更具体的接口定义，例如：

```java
public interface NovelCreator {

    @Agent
    String createNovel(@V("topic") String topic, @V("audience") String audience, @V("style") String style);

}
```

基于该类型化接口，`novelCreator` 智能体的创建与使用方式如下：

```java
NovelCreator novelCreator = AgenticServices
        .sequenceBuilder(NovelCreator.class)
        .subAgents(creativeWriter, audienceEditor, styleEditor)
        .outputKey("story")
        .build();

String story = novelCreator.createNovel("龙与巫师", "青年", "奇幻");
```

### 循环工作流

充分发挥 LLM 能力的常见方式之一，是通过重复调用文本编辑类智能体（如故事优化智能体），实现文本片段的迭代改进。这一需求可通过循环工作流模式实现，该模式下智能体将被重复调用，直至满足预设退出条件。

可先定义 `StyleScorer` 智能体，用于根据故事与目标风格的契合程度生成分数（评分范围为 0.0 - 1.0）。

```java title="StyleScorer.java"
public interface StyleScorer {

    @UserMessage("""
            你是一位严格的评论家。
            请根据以下故事与风格 '{{style}}' 的契合程度，给出一个 0.0 到 1.0 之间的评分。
            只返回评分数字，不要返回其他内容。
            故事内容："{{story}}"
            """)
    @Agent("根据故事与给定风格的契合程度进行评分")
    double scoreStyle(@V("story") String story, @V("style") String style);

}
```

随后，可将 `StyleScorer` 智能体与 `StyleEditor` 智能体整合到循环工作流中，通过迭代编辑与评分，持续优化故事内容，直至评分达到预设阈值（如 0.8）或达到最大迭代次数，具体实现如下：

```java title="LoopWorkflowExample.java"
import dev.langchain4j.agentic.Agent;
import dev.langchain4j.agentic.AgenticServices;
import dev.langchain4j.agentic.UntypedAgent;
import dev.langchain4j.model.chat.ChatModel;
import dev.langchain4j.model.openai.OpenAiChatModel;
import dev.langchain4j.service.UserMessage;
import dev.langchain4j.service.V;

public class LoopWorkflowExample {

    public interface CreativeWriter {

        @UserMessage("""
                你是一位创意作家。
                请围绕给定主题生成一个不超过3句话的故事草稿。
                只返回故事内容，不要返回其他内容。
                主题：{{topic}}
                """)
        @Agent("根据给定主题生成故事草稿")
        String generateStory(@V("topic") String topic);

    }

    public interface StyleEditor {

        @UserMessage("""
                你是一位专业编辑。
                分析并重写以下故事，使其更好地符合并更连贯地体现 {{style}} 风格。
                只返回故事内容，不要返回其他内容。
                故事内容："{{story}}"
                """)
        @Agent("编辑故事以更好地适应给定的风格")
        String editStory(@V("story") String story, @V("style") String style);

    }
    
    public interface StyleScorer {

        @UserMessage("""
                你是一位严格的评论家。
                请根据以下故事与风格 '{{style}}' 的契合程度，给出一个 0.0 到 1.0 之间的评分。
                只返回评分数字，不要返回其他内容。
                故事内容："{{story}}"
                """)
        @Agent("根据故事与给定风格的契合程度进行评分")
        double scoreStyle(@V("story") String story, @V("style") String style);

    }
    
    public interface StyledWriter {

        @Agent
        String writeStoryWithStyle(@V("topic") String topic, @V("style") String style);

    }

    public static void main(String[] args) {
        // 创建对话模型
        ChatModel baseModel = OpenAiChatModel.builder()
                .baseUrl("https://api.deepseek.com/v1")
                .apiKey(System.getenv("DEEPSEEK_API_KEY"))
                .modelName("deepseek-chat")
                .logRequests(true)
                .logResponses(true)
                .build();

        // 创建风格编辑智能体
        StyleEditor styleEditor = AgenticServices
                .agentBuilder(StyleEditor.class)
                .chatModel(baseModel)
                .outputKey("story")
                .build();

        // 创建风格评分智能体
        StyleScorer styleScorer = AgenticServices
                .agentBuilder(StyleScorer.class)
                .chatModel(baseModel)
                .outputKey("score")
                .build();

        // 创建循环工作流：循环评分和编辑，直到达到满意的分数
        UntypedAgent styleReviewLoop = AgenticServices
                .loopBuilder()
                .subAgents(styleScorer, styleEditor)
                .maxIterations(5)
                .testExitAtLoopEnd(true)
                .exitCondition(agenticScope -> agenticScope.readState("score", 0.0) >= 0.8)
                .build();

        // 创建创意作家智能体
        CreativeWriter creativeWriter = AgenticServices
                .agentBuilder(CreativeWriter.class)
                .chatModel(baseModel)
                .outputKey("story")
                .build();

        // 创建风格化作家：先生成故事，然后循环优化
        StyledWriter styledWriter = AgenticServices
                .sequenceBuilder(StyledWriter.class)
                .subAgents(creativeWriter, styleReviewLoop)
                .outputKey("story")
                .build();

        // 执行工作流
        String story = styledWriter.writeStoryWithStyle("龙与巫师", "喜剧");

        // 输出结果
        System.out.println("=== 最终生成的故事 ===");
        System.out.println(story);
        System.out.println();
        System.out.println("=== 工作流执行完成 ===");
    }

}
```

上述代码中，`styleScorer` 智能体将评分结果写入 `AgenticScope` 中名为 `score` 的共享变量，循环的退出条件通过读取该变量值进行判断。

`exitCondition` 方法支持接收 `Predicate<AgenticScope>` 作为参数，默认在每次智能体调用后触发条件评估，一旦满足条件即退出循环，以减少不必要的智能体调用。若需强制在所有智能体调用完成后再检查退出条件，可通过 `testExitAtLoopEnd(true)` 方法配置循环构建器。此外，`exitCondition` 方法还支持接收 `BiPredicate<AgenticScope, Integer>` 作为参数，该参数的第二个输入值为当前循环迭代计数器，示例如下：

```java
UntypedAgent styleReviewLoop = AgenticServices
        .loopBuilder()
        .subAgents(styleScorer, styleEditor)
        .maxIterations(5)
        .testExitAtLoopEnd(true)
        .exitCondition((agenticScope, loopCounter) -> {
            double score = agenticScope.readState("score", 0.0);
            return loopCounter <= 3 ? score >= 0.8 : score >= 0.6;
        })
        .build();
```

该配置使得循环在前 3 次迭代中，若评分达到 0.8 及以上则退出；后续迭代中，评分阈值降至 0.6，即使满足退出条件，仍会强制调用最后一次 `styleEditor` 智能体。

`styleReviewLoop` 配置完成后，可将其视为独立智能体，与 `CreativeWriter` 智能体按顺序组合，构建 `StyledWriter` 智能体。

### 并行工作流

在部分场景下，并行调用多个智能体具有显著优势，尤其当这些智能体可基于同一输入独立完成任务时。这一需求可通过并行工作流模式实现，该模式下多个智能体将被同时调用，其输出结果将被组合为单一最终结果。

例如，需为特定心情的用户生成晚间计划，包含匹配该心情的电影推荐与餐食推荐，可分别定义 `FoodExpert` 智能体与 `MovieExpert` 智能体：

```java title="FoodExpert.java"
public interface FoodExpert {

    @UserMessage("""
            你是一位出色的晚间计划专家。
            请根据给定的心情推荐3个匹配的餐食。
            心情：{{mood}}
            对于每个餐食，只需提供餐食名称。
            提供一个包含3个项目的列表，不要返回其他内容。
            """)
    @Agent
    List<String> findMeal(@V("mood") String mood);

}

public interface MovieExpert {

    @UserMessage("""
            你是一位出色的晚间计划专家。
            请根据给定的心情推荐3个匹配的电影。
            心情：{{mood}}
            提供一个包含3个项目的列表，不要返回其他内容。
            """)
    @Agent
    List<String> findMovie(@V("mood") String mood);

}
```

由于两个智能体的任务执行相互独立，可通过 `AgenticServices.parallelBuilder()` 方法实现并行调用，具体如下：

```java title="ParallelWorkflowExample.java"
import dev.langchain4j.agentic.Agent;
import dev.langchain4j.agentic.AgenticServices;
import dev.langchain4j.agentic.scope.AgenticScope;
import dev.langchain4j.model.chat.ChatModel;
import dev.langchain4j.model.openai.OpenAiChatModel;
import dev.langchain4j.service.UserMessage;
import dev.langchain4j.service.V;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ParallelWorkflowExample {

    public static class EveningPlan {

        private final String movie;
        private final String meal;

        public EveningPlan(String movie, String meal) {
            this.movie = movie;
            this.meal = meal;
        }

        public String getMovie() {
            return movie;
        }

        public String getMeal() {
            return meal;
        }

        @Override
        public String toString() {
            return "电影：" + movie + " | 餐食：" + meal;
        }

    }

    public interface FoodExpert {

        @UserMessage("""
                你是一位出色的晚间计划专家。
                请根据给定的心情推荐3个匹配的餐食。
                心情：{{mood}}
                对于每个餐食，只需提供餐食名称。
                提供一个包含3个项目的列表，不要返回其他内容。
                """)
        @Agent
        List<String> findMeal(@V("mood") String mood);

    }

    public interface MovieExpert {

        @UserMessage("""
                你是一位出色的晚间计划专家。
                请根据给定的心情推荐3个匹配的电影。
                心情：{{mood}}
                提供一个包含3个项目的列表，不要返回其他内容。
                """)
        @Agent
        List<String> findMovie(@V("mood") String mood);

    }

    public interface EveningPlannerAgent {

        List<EveningPlan> plan(@V("mood") String mood);

    }

    public static void main(String[] args) {
        // 创建对话模型
        ChatModel baseModel = OpenAiChatModel.builder()
                .baseUrl("https://api.deepseek.com/v1")
                .apiKey(System.getenv("DEEPSEEK_API_KEY"))
                .modelName("deepseek-chat")
                .logRequests(true)
                .logResponses(true)
                .build();

        // 创建食物专家智能体
        FoodExpert foodExpert = AgenticServices
                .agentBuilder(FoodExpert.class)
                .chatModel(baseModel)
                .outputKey("meals")
                .build();

        // 创建电影专家智能体
        MovieExpert movieExpert = AgenticServices
                .agentBuilder(MovieExpert.class)
                .chatModel(baseModel)
                .outputKey("movies")
                .build();

        // 创建线程池（需要保存引用以便后续关闭）
        ExecutorService executor = Executors.newFixedThreadPool(2);

        try {
            // 创建并行工作流：并行执行食物和电影推荐，然后组合结果
            EveningPlannerAgent eveningPlannerAgent = AgenticServices
                    .parallelBuilder(EveningPlannerAgent.class)
                    .subAgents(foodExpert, movieExpert)
                    .executor(executor)
                    .outputKey("plans")
                    .output((AgenticScope agenticScope) -> {
                        List<String> movies = agenticScope.readState("movies", List.of());
                        List<String> meals = agenticScope.readState("meals", List.of());

                        List<EveningPlan> moviesAndMeals = new ArrayList<>();
                        for (int i = 0; i < movies.size(); i++) {
                            if (i >= meals.size()) {
                                break;
                            }
                            moviesAndMeals.add(new EveningPlan(movies.get(i), meals.get(i)));
                        }
                        return moviesAndMeals;
                    })
                    .build();

            // 执行工作流
            List<EveningPlan> plans = eveningPlannerAgent.plan("浪漫");

            // 输出结果
            System.out.println("=== 晚间计划推荐 ===");
            for (int i = 0; i < plans.size(); i++) {
                System.out.println("方案 " + (i + 1) + ": " + plans.get(i));
            }
            System.out.println();
            System.out.println("=== 工作流执行完成 ===");
        } finally {
            // 关闭线程池，确保程序可以正常退出
            executor.shutdown();
        }
    }

}
```

上述代码中，`EveningPlannerAgent` 借助 `output` 方法，对两个子智能体的输出结果进行组装，最终完成电影与餐食的匹配组合，生成 `EveningPlan` 对象列表。需要说明的是，`output` 方法并非仅适用于并行工作流，还可在其他工作流模式中使用，其核心作用是定义子智能体输出结果的组合逻辑，而非简单从 `AgenticScope` 获取返回值。此外，`executor` 方法还支持可选配置 `Executor` 实例作为参数，以实现子智能体的并行执行；若未主动配置该实例，框架将默认采用内部缓存线程池。

### 条件分支工作流

另一常见需求是仅在满足特定条件时调用目标智能体。例如，可在任务处理前对用户请求进行分类，根据分类结果由对应专业智能体进行处理，提升响应精准度。这一需求可通过 `CategoryRouter` 智能体实现，该智能体用于对用户请求进行分类。

```java title="CategoryRouter.java"
public interface CategoryRouter {

    @UserMessage("""
            分析以下用户请求，并将其分类为 'legal'（法律）、'medical'（医疗）或 'technical'（技术）。
            如果请求不属于以上任何类别，则分类为 'unknown'（未知）。
            只返回其中一个词，不要返回其他内容。
            用户请求是：'{{request}}'。
            """)
    @Agent("对用户请求进行分类")
    RequestCategory classify(@V("request") String request);

}
```

它返回一个 `RequestCategory` 枚举值。

```java
public enum RequestCategory {
    LEGAL,      // 法律
    MEDICAL,    // 医疗
    TECHNICAL,  // 技术
    UNKNOWN     // 未知
}
```

这样，定义一个 `MedicalExpert` 智能体，以及类似的 `LegalExpert` 和 `TechnicalExpert` 智能体，可构建 `ExpertRouterAgent`，实现条件工作流，根据用户请求的类别调用相应的智能体。

```java title="ConditionalWorkflowExample.java"
import dev.langchain4j.agentic.Agent;
import dev.langchain4j.agentic.AgenticServices;
import dev.langchain4j.agentic.UntypedAgent;
import dev.langchain4j.model.chat.ChatModel;
import dev.langchain4j.model.openai.OpenAiChatModel;
import dev.langchain4j.service.UserMessage;
import dev.langchain4j.service.V;

public class ConditionalWorkflowExample {

    public enum RequestCategory {
        LEGAL,      // 法律
        MEDICAL,    // 医疗
        TECHNICAL,  // 技术
        UNKNOWN     // 未知
    }

    public interface CategoryRouter {

        @UserMessage("""
                分析以下用户请求，并将其分类为 'legal'（法律）、'medical'（医疗）或 'technical'（技术）。
                如果请求不属于以上任何类别，则分类为 'unknown'（未知）。
                只返回其中一个词，不要返回其他内容。
                用户请求是：'{{request}}'。
                """)
        @Agent("对用户请求进行分类")
        RequestCategory classify(@V("request") String request);

    }

    public interface MedicalExpert {

        @UserMessage("""
                你是一位医疗专家。
                请从医疗角度分析以下用户请求，并提供最佳答案。
                用户请求是：{{request}}。
                """)
        @Agent("医疗专家")
        String medical(@V("request") String request);

    }

    public interface LegalExpert {

        @UserMessage("""
                你是一位法律专家。
                请从法律角度分析以下用户请求，并提供最佳答案。
                用户请求是：{{request}}。
                """)
        @Agent("法律专家")
        String legal(@V("request") String request);

    }

    public interface TechnicalExpert {

        @UserMessage("""
                你是一位技术专家。
                请从技术角度分析以下用户请求，并提供最佳答案。
                用户请求是：{{request}}。
                """)
        @Agent("技术专家")
        String technical(@V("request") String request);

    }

    public interface ExpertRouterAgent {

        @Agent
        String ask(@V("request") String request);

    }

    public static void main(String[] args) {
        // 创建对话模型
        ChatModel baseModel = OpenAiChatModel.builder()
                .baseUrl("https://api.deepseek.com/v1")
                .apiKey(System.getenv("DEEPSEEK_API_KEY"))
                .modelName("deepseek-chat")
                .logRequests(true)
                .logResponses(true)
                .build();

        // 创建分类路由智能体
        CategoryRouter routerAgent = AgenticServices
                .agentBuilder(CategoryRouter.class)
                .chatModel(baseModel)
                .outputKey("category")
                .build();

        // 创建医疗专家智能体
        MedicalExpert medicalExpert = AgenticServices
                .agentBuilder(MedicalExpert.class)
                .chatModel(baseModel)
                .outputKey("response")
                .build();

        // 创建法律专家智能体
        LegalExpert legalExpert = AgenticServices
                .agentBuilder(LegalExpert.class)
                .chatModel(baseModel)
                .outputKey("response")
                .build();

        // 创建技术专家智能体
        TechnicalExpert technicalExpert = AgenticServices
                .agentBuilder(TechnicalExpert.class)
                .chatModel(baseModel)
                .outputKey("response")
                .build();

        // 创建条件工作流：根据分类结果选择执行相应的专家
        UntypedAgent expertsAgent = AgenticServices.conditionalBuilder()
                .subAgents(agenticScope -> agenticScope.readState("category", RequestCategory.UNKNOWN) == RequestCategory.MEDICAL, medicalExpert)
                .subAgents(agenticScope -> agenticScope.readState("category", RequestCategory.UNKNOWN) == RequestCategory.LEGAL, legalExpert)
                .subAgents(agenticScope -> agenticScope.readState("category", RequestCategory.UNKNOWN) == RequestCategory.TECHNICAL, technicalExpert)
                .build();

        // 创建专家路由智能体：先分类，然后根据分类结果选择专家
        ExpertRouterAgent expertRouterAgent = AgenticServices
                .sequenceBuilder(ExpertRouterAgent.class)
                .subAgents(routerAgent, expertsAgent)
                .outputKey("response")
                .build();

        // 执行工作流
        String response = expertRouterAgent.ask("我摔断了腿，应该怎么办？");

        // 输出结果
        System.out.println("=== 专家回答 ===");
        System.out.println(response);
        System.out.println();
        System.out.println("=== 工作流执行完成 ===");
    }

}
```

## 总结

本文介绍了 LangChain4j 智能体的基础概念和四种主要工作流模式：

- **顺序工作流**：智能体按顺序执行，前一个的输出作为下一个的输入；
- **循环工作流**：智能体重复执行，直到满足退出条件；
- **并行工作流**：多个智能体同时执行，提高执行效率；
- **条件分支工作流**：根据条件选择执行不同的智能体。

这些工作流模式可以组合使用，构建更复杂的智能体系统。`AgenticScope` 作为共享上下文，使智能体之间能够有效协作。

在下一篇文章中，我们将介绍智能体的执行特性（异步、流式）和可观测性功能。

## 参考文档

- [LangChain4j 官方文档 - Agents](https://docs.langchain4j.dev/tutorials/agents)
